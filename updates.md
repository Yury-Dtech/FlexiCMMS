# Отчет об оптимизации и план устранения недочетов 

## Обнаруженные недочеты:

### 1. Дублирование запросов к API и неэффективная загрузка данных

*   **Многократные вызовы `UserState.LoadIdentityDataAsync`:** Метод вызывается несколько раз при старте приложения и инициализации `MainLayout`, что приводит к избыточной загрузке данных идентификации.
*   **Многократные запросы `GET /api/v1/settings/get`:** Запрос на получение настроек выполняется несколько раз при старте и после авторизации, хотя данные, вероятно, статичны для сессии.
*   **Многократные запросы `GET /api/v1/identity/check-session`:** Проверка сессии выполняется избыточно при старте и навигации.
*   **Многократные запросы `GET /api/v1/other/getuserslist`:** Список пользователей запрашивается многократно, хотя данные редко меняются.
*   **Многократные запросы `GET /api/v1/device/getlist`:** Список устройств запрашивается многократно.
*   **Многократные запросы `GET /api/v1/wo/getlist?*`:** Списки рабочих ордеров запрашиваются несколько раз.
*   **Многократные запросы `GET /api/v1/wo/getdict?*`:** Словари рабочих ордеров запрашиваются многократно.
*   **Чрезмерное количество `POST /api/v1/settings/save-view-settings?*`:** Настройки вида сохраняются слишком часто (более 10 раз) в короткий промежуток времени.
*   **Чрезмерное количество `GET /api/v1/device/getstate?*`:** Состояние устройств запрашивается индивидуально и многократно (более 20 раз) при переходе на страницу устройств, что крайне неэффективно.
*   **Ошибка `400 (Bad Request)` для `wo/getlist?IsWithPerson=true&PersonID=0&Lang=`:** Запрос отправляется с некорректным `PersonID=0`.

### 2. Избыточное логирование

*   **Дублирование логов HTTP-запросов:** Каждый HTTP-запрос логируется дважды (`Start processing` и `Sending`).
*   **Многократное логирование `LoadIdentityDataAsync started.` и `Culture set to pl-PL`:** Эти логи появляются слишком часто.
*   **Многократное логирование ответов API:** Логи `[MES] = = = = = = = response Dict.Count: 32` и `[MES] = = = = = = = API response-> WorkOrder.Count: 231` дублируются.
*   **Многократное логирование кэширования устройств:** Логи `[MES] Device status for lang pl-PL found in cache.` появляются по одному на каждое устройство.

### 3. Недостаточное логирование

*   **Отсутствие логов завершения сохранения `UserState.SaveIdentityDataAsync`:** Нет информации о том, что именно было сохранено.
*   **Недостаток контекста для ошибок Telerik Scheduler:** Критическая ошибка `NullReferenceException` не содержит достаточной информации для отладки.
*   **Неконсистентное логирование инициализации страниц:** Не все страницы логируют свою инициализацию.
*   **Отсутствие логов о добавлении данных в кэш:** Нет информации о том, когда данные помещаются в кэш.

### 4. Проблемы структуры компонентов

*   **`System.NullReferenceException` в Telerik Scheduler:** Указывает на неправильную инициализацию данных или асинхронную загрузку, приводящую к рендерингу компонента до готовности данных.
*   **Децентрализованные API-запросы:** Компоненты, вероятно, делают свои собственные API-запросы без централизованного управления состоянием или кэширования, что приводит к дублированию.

## План устранения недочетов:

### 1. Оптимизация запросов к API и загрузки данных

*   **Централизовать загрузку IdentityData:**
    *   В `UserState.cs` реализовать механизм, который гарантирует, что `LoadIdentityDataAsync` вызывается только один раз при старте приложения или при явном сбросе состояния пользователя.
    *   Использовать `Lazy<Task<T>>` или аналогичный подход для асинхронной инициализации данных по требованию, но только один раз.
*   **Внедрить кэширование на стороне клиента (Client-side Caching):**
    *   Для статических или редко изменяющихся данных (настройки, списки пользователей, словари, списки устройств) реализовать механизм кэширования в `ApiServiceClient` или специализированных сервисах.
    *   Использовать `MemoryCache` или `LocalStorage` (для данных, которые должны сохраняться между сессиями) для хранения ответов API.
    *   Пример: `GET /api/v1/settings/get`, `GET /api/v1/other/getuserslist`, `GET /api/v1/device/getlist`, `GET /api/v1/wo/getdict?*`.
*   **Оптимизировать запросы `GET /api/v1/device/getstate?*`:**
    *   Изменить логику на странице устройств (`DevicesPage.razor` или связанный компонент), чтобы вместо множественных индивидуальных запросов `getstate` для каждого устройства, выполнялся один запрос, который возвращает состояния для всех необходимых устройств. Если API не поддерживает это, рассмотреть возможность модификации API.
*   **Оптимизировать сохранение настроек вида `POST /api/v1/settings/save-view-settings?*`:**
    *   Реализовать механизм "debounce" или "throttle" для сохранения настроек. Сохранять настройки только после того, как пользователь прекратил вносить изменения в течение определенного периода времени (например, 500 мс) или при явном действии сохранения.
*   **Исправить ошибку `PersonID=0`:**
    *   Проанализировать код, который формирует запрос `wo/getlist?IsWithPerson=true&PersonID=0&Lang=`. Убедиться, что `PersonID` корректно инициализируется из `UserState` и не отправляется с нулевым значением, если ожидается положительное число. Возможно, добавить проверку на `PersonID > 0` перед отправкой запроса.
*   **Использовать `AppStateService` для общего состояния:**
    *   Убедиться, что `AppStateService` используется для управления общим состоянием приложения и обмена данными между компонентами, чтобы избежать дублирования запросов и обеспечить единый источник истины для данных.

### 2. Оптимизация логирования

*   **Сократить дублирование логов HTTP-запросов:**
    *   Модифицировать `AuthHeaderHandler` или другой HTTP-интерцептор, чтобы логировать каждый запрос только один раз (например, `Request: GET /api/v1/settings/get` и `Response: GET /api/v1/settings/get - 200 OK`).
*   **Сократить избыточные логи `UserState`:**
    *   Логи `LoadIdentityDataAsync started.` и `Culture set to pl-PL` выводить только при первом вызове или при изменении состояния.
*   **Сократить логи ответов API:**
    *   Логи `[MES] = = = = = = = response Dict.Count: 32` и `[MES] = = = = = = = API response-> WorkOrder.Count: 231` выводить один раз за успешный запрос, возможно, с более подробной информацией, если это необходимо для отладки.
*   **Оптимизировать логи кэширования устройств:**
    *   Вместо логирования каждого кэшированного устройства, логировать общее количество устройств, найденных в кэше, или только при первом доступе к кэшу.

### 3. Улучшение логирования

*   **Добавить логи завершения сохранения `UserState.SaveIdentityDataAsync`:**
    *   После успешного сохранения `IdentityData` добавить лог, указывающий на это, например: `DEBUG: IdentityData saved to local storage. User: [UserName], Lang: [LangCode]`.
*   **Улучшить логирование ошибок Telerik Scheduler:**
    *   В компонентах, использующих Telerik Scheduler (например, `Scheduler.razor`, `ActivitiesPage.razor`), добавить `try-catch` блоки вокруг логики, которая взаимодействует с компонентом. В блоке `catch` логировать полную информацию об исключении, включая `InnerException` и значения переменных, которые могли привести к `NullReferenceException`.
    *   Перед передачей данных в Telerik Scheduler, добавить логирование этих данных, чтобы убедиться, что они не `null` или пусты.
*   **Консистентное логирование инициализации страниц:**
    *   Добавить логирование `OnInitializedAsync` для всех основных страниц, чтобы отслеживать их жизненный цикл.
*   **Добавить логи о добавлении данных в кэш:**
    *   При помещении данных в кэш, добавить лог, например: `DEBUG: Caching data for [API_Endpoint]. Count: [Count]`.

### 4. Улучшение структуры компонентов

*   **Решить `NullReferenceException` в Telerik Scheduler:**
    *   Проверить, что данные, передаваемые в `Telerik.Blazor.Components.Scheduler.Rendering.ContentTableBase`, полностью инициализированы и не `null` до того, как компонент попытается их использовать. Возможно, использовать условный рендеринг (`@if (DataLoaded) { <TelerikScheduler ... /> }`) или инициализировать данные значениями по умолчанию.
    *   Изучить документацию Telerik Scheduler для лучших практик по асинхронной загрузке данных и их привязке.
*   **Централизовать управление состоянием и данными:**
    *   Использовать `AppStateService` или другие механизмы управления состоянием (например, Flux/Redux-подобные паттерны, если применимо) для централизованной загрузки и хранения данных, которые используются несколькими компонентами. Это позволит избежать дублирования запросов и обеспечит единый источник истины.
    *   Использовать `CascadingParameters` для передачи общих данных вниз по дереву компонентов, чтобы избежать повторных запросов.
