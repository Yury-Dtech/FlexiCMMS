@* Reusable timer component for Blazor WASM / Server (Stopwatch & Random removed for AOT safety) *@
@code {
    private System.Threading.Timer? _timer;
    private CancellationTokenSource? _cts;
    private DateTimeOffset _startedAt;
    private DateTimeOffset? _lastTickAt;
    private int _tickCount;
    private bool _isBusy;
    private DateTimeOffset? _lastTickRealTime;
    private System.Threading.Timer? _uiTimer;
    private TimeSpan? _lastTickDuration;
    private double _avgTickMs; // simple moving average in ms
    private bool _disposed;
    private int _prngState = (int)(DateTime.UtcNow.Ticks & 0x7FFFFFFF);

    public class TimerSnapshot
    {
        public required DateTimeOffset StartedAt { get; init; }
        public DateTimeOffset? LastTickAt { get; init; }
        public int TickCount { get; init; }
        public bool IsRunning { get; init; }
        public bool IsBusy { get; init; }
        public TimeSpan Interval { get; init; }
        public TimeSpan? TimeLeft { get; init; }
        public TimeSpan? LastTickDuration { get; init; }
        public TimeSpan? AverageTickDuration { get; init; }
    }

    [Parameter] public TimeSpan Interval { get; set; } = TimeSpan.FromSeconds(60);
    [Parameter] public bool Paused { get; set; }
    [Parameter] public EventCallback OnTick { get; set; }
    [Parameter] public Func<Task>? TickAsync { get; set; }
    [Parameter] public bool AutoStart { get; set; } = true;
    [Parameter] public bool FireImmediately { get; set; } = true;
    [Parameter] public bool SkipIfBusy { get; set; } = true;
    [Parameter] public int JitterMilliseconds { get; set; } = 0; // now only 0..N (только положительный)
    [Parameter] public TimeSpan? SoftTickTimeout { get; set; }
    [Parameter] public RenderFragment<TimerSnapshot>? ChildContent { get; set; }
    [Parameter] public EventCallback<Exception> OnError { get; set; }
    [Parameter] public EventCallback OnStarted { get; set; }
    [Parameter] public EventCallback OnStopped { get; set; }
    [Parameter] public bool EnableUiUpdates { get; set; } = true;
    [Parameter] public TimeSpan UiUpdateInterval { get; set; } = TimeSpan.FromSeconds(1);

    private TimerSnapshot Snapshot => new()
    {
        StartedAt = _startedAt,
        LastTickAt = _lastTickAt,
        TickCount = _tickCount,
        IsRunning = _timer != null && !_disposed && !Paused,
        IsBusy = _isBusy,
        Interval = Interval,
        TimeLeft = GetTimeLeft(),
        LastTickDuration = _lastTickDuration,
        AverageTickDuration = _avgTickMs > 0 ? TimeSpan.FromMilliseconds(_avgTickMs) : null
    };

    private TimeSpan? GetTimeLeft()
    {
        if (_lastTickRealTime == null) return null;
        var nextTick = _lastTickRealTime.Value + Interval;
        var left = nextTick - DateTimeOffset.UtcNow;
        if (left < TimeSpan.Zero) left = TimeSpan.Zero;
        return left;
    }

    protected override async Task OnInitializedAsync()
    {
        if (AutoStart && !Paused)
        {
            await StartInternalAsync();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Interval.TotalMilliseconds < 500)
        {
            Interval = TimeSpan.FromMilliseconds(500);
        }
        if (_timer != null && _previousInterval != Interval)
        {
            await RestartAsync();
        }

        if (Paused && _timer != null)
        {
            await StopInternalAsync();
        }
        else if (!Paused && _timer == null && AutoStart)
        {
            await StartInternalAsync();
        }

        if (_uiTimer != null && EnableUiUpdates && UiUpdateInterval != _currentUiInterval)
        {
            RestartUiTimer();
        }
    }

    private TimeSpan _previousInterval;
    private TimeSpan _currentUiInterval;

    public async Task StartAsync() => await StartInternalAsync();
    public async Task StopAsync() => await StopInternalAsync();
    public async Task RestartAsync()
    {
        await StopInternalAsync();
        if (!Paused) await StartInternalAsync();
    }

    private async Task StartInternalAsync()
    {
        await StopInternalAsync();
        _disposed = false;
        _previousInterval = Interval;
        _cts = new CancellationTokenSource();
        _startedAt = DateTimeOffset.UtcNow;
        _lastTickAt = null;
        _tickCount = 0;
        _lastTickRealTime = DateTimeOffset.UtcNow;
        _lastTickDuration = null;
        _avgTickMs = 0;
        _prngState = (int)(DateTime.UtcNow.Ticks & 0x7FFFFFFF);
        StartUiTimer();
        _timer = new System.Threading.Timer(TimerCallback, null, FireImmediately ? TimeSpan.Zero : Interval, Interval);
        if (OnStarted.HasDelegate)
        {
            await OnStarted.InvokeAsync(null);
        }
        StateHasChanged();
    }

    private void TimerCallback(object? state)
    {
        if (_disposed || Paused) return;
        // async void pattern only inside timer callback boundary
        _ = SafeTriggerAsync();
    }

    private async Task SafeTriggerAsync()
    {
        try { await InvokeAsync(TriggerTickAsync); } catch (Exception ex) { if (OnError.HasDelegate) { try { await OnError.InvokeAsync(ex); } catch { } } }
    }

    private void StartUiTimer()
    {
        if (!EnableUiUpdates || UiUpdateInterval <= TimeSpan.Zero) return;
        _currentUiInterval = UiUpdateInterval;
        _uiTimer = new System.Threading.Timer(async _ =>
        {
            if (_disposed || Paused) return;
            try { await InvokeAsync(StateHasChanged); } catch { }
        }, null, UiUpdateInterval, UiUpdateInterval);
    }

    private void RestartUiTimer()
    {
        try { _uiTimer?.Dispose(); } catch { }
        _uiTimer = null;
        StartUiTimer();
    }

    private async Task StopInternalAsync()
    {
        _disposed = true;
        try { _cts?.Cancel(); _cts?.Dispose(); } catch { }
        _cts = null;
        try { _timer?.Dispose(); } catch { }
        _timer = null;
        try { _uiTimer?.Dispose(); } catch { }
        _uiTimer = null;
        if (OnStopped.HasDelegate)
        {
            await OnStopped.InvokeAsync(null);
        }
        StateHasChanged();
    }

    // Простая LCG для избежания Random.Next (AOT issue)
    private int NextPrng(int maxExclusive)
    {
        // LCG параметры (glibc стиль)
        _prngState = (1103515245 * _prngState + 12345) & 0x7fffffff;
        if (maxExclusive <= 1) return 0;
        return _prngState % maxExclusive;
    }

    private async Task TriggerTickAsync()
    {
        if (_isBusy && SkipIfBusy) return;
        _isBusy = true;
        var tickStart = DateTime.UtcNow;
        Exception? error = null;
        try
        {
            if (JitterMilliseconds > 0)
            {
                var jitter = NextPrng(JitterMilliseconds + 1); // 0..JitterMilliseconds
                if (jitter > 0) await Task.Delay(jitter);
            }
            if (OnTick.HasDelegate)
            {
                await OnTick.InvokeAsync(null);
            }
            if (TickAsync is not null)
            {
                await TickAsync();
            }
            _tickCount++;
            _lastTickAt = DateTimeOffset.UtcNow;
            _lastTickRealTime = DateTimeOffset.UtcNow;
        }
        catch (Exception ex)
        {
            error = ex;
            if (OnError.HasDelegate)
            {
                try { await OnError.InvokeAsync(ex); } catch { }
            }
        }
        finally
        {
            var elapsed = DateTime.UtcNow - tickStart;
            _lastTickDuration = elapsed;
            var elapsedMs = elapsed.TotalMilliseconds;
            _avgTickMs = _avgTickMs == 0 ? elapsedMs : (_avgTickMs * 0.8 + elapsedMs * 0.2);

            if (SoftTickTimeout.HasValue && elapsed > SoftTickTimeout.Value && !SkipIfBusy)
            {
                try { await Task.Delay(100); } catch { }
            }

            _isBusy = false;
            if (error == null)
            {
                try { await InvokeAsync(StateHasChanged); } catch { }
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        await StopInternalAsync();
    }
}

@if (ChildContent is not null)
{
    @ChildContent(Snapshot)
}

@* Example usage (place in a page):
<Timer Interval="TimeSpan.FromSeconds(15)"
       UiUpdateInterval="TimeSpan.FromSeconds(1)"
       OnTick="@(async () => await RefreshDataAsync())"
       JitterMilliseconds="250"
       SoftTickTimeout="@(TimeSpan.FromSeconds(10))">
    <ChildContent Context="ctx">
        <div>
            Next update in: @(ctx.TimeLeft?.ToString("mm':'ss") ?? "-")<br />
            Last tick: @(ctx.LastTickDuration?.TotalMilliseconds.ToString("F0") ?? "-") ms | Avg: @(ctx.AverageTickDuration?.TotalMilliseconds.ToString("F0") ?? "-") ms
        </div>
    </ChildContent>
</Timer>
*@
